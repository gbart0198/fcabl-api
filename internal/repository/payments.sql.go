// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (player_id, transaction_id, amount, status, payment_date)
VALUES ($1, $2, $3, $4, NOW())
RETURNING id, player_id, transaction_id, amount, status, payment_date
`

type CreatePaymentParams struct {
	PlayerID      int64  `json:"playerId"`
	TransactionID string `json:"transactionId"`
	Amount        int32  `json:"amount"`
	Status        string `json:"status"`
}

// CreatePayment
//
//	INSERT INTO payments (player_id, transaction_id, amount, status, payment_date)
//	VALUES ($1, $2, $3, $4, NOW())
//	RETURNING id, player_id, transaction_id, amount, status, payment_date
func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.PlayerID,
		arg.TransactionID,
		arg.Amount,
		arg.Status,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.TransactionID,
		&i.Amount,
		&i.Status,
		&i.PaymentDate,
	)
	return i, err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payments
WHERE id = $1
`

// DeletePayment
//
//	DELETE FROM payments
//	WHERE id = $1
func (q *Queries) DeletePayment(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePayment, id)
	return err
}

const getPaymentById = `-- name: GetPaymentById :one
SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments WHERE id = $1
`

// GetPaymentById
//
//	SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments WHERE id = $1
func (q *Queries) GetPaymentById(ctx context.Context, id int64) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentById, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.TransactionID,
		&i.Amount,
		&i.Status,
		&i.PaymentDate,
	)
	return i, err
}

const getPaymentByTransactionId = `-- name: GetPaymentByTransactionId :one
SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments WHERE transaction_id = $1
`

// GetPaymentByTransactionId
//
//	SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments WHERE transaction_id = $1
func (q *Queries) GetPaymentByTransactionId(ctx context.Context, transactionID string) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByTransactionId, transactionID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.TransactionID,
		&i.Amount,
		&i.Status,
		&i.PaymentDate,
	)
	return i, err
}

const getPaymentWithPlayer = `-- name: GetPaymentWithPlayer :one
SELECT py.id, py.player_id, py.transaction_id, py.amount, py.status, py.payment_date, p.user_id, u.email, u.first_name, u.last_name
FROM payments py
INNER JOIN players p ON py.player_id = p.id
INNER JOIN users u ON p.user_id = u.id
WHERE py.id = $1
`

type GetPaymentWithPlayerRow struct {
	ID            int64            `json:"id"`
	PlayerID      int64            `json:"playerId"`
	TransactionID string           `json:"transactionId"`
	Amount        int32            `json:"amount"`
	Status        string           `json:"status"`
	PaymentDate   pgtype.Timestamp `json:"paymentDate"`
	UserID        int64            `json:"userId"`
	Email         string           `json:"email"`
	FirstName     string           `json:"firstName"`
	LastName      string           `json:"lastName"`
}

// GetPaymentWithPlayer
//
//	SELECT py.id, py.player_id, py.transaction_id, py.amount, py.status, py.payment_date, p.user_id, u.email, u.first_name, u.last_name
//	FROM payments py
//	INNER JOIN players p ON py.player_id = p.id
//	INNER JOIN users u ON p.user_id = u.id
//	WHERE py.id = $1
func (q *Queries) GetPaymentWithPlayer(ctx context.Context, id int64) (GetPaymentWithPlayerRow, error) {
	row := q.db.QueryRow(ctx, getPaymentWithPlayer, id)
	var i GetPaymentWithPlayerRow
	err := row.Scan(
		&i.ID,
		&i.PlayerID,
		&i.TransactionID,
		&i.Amount,
		&i.Status,
		&i.PaymentDate,
		&i.UserID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getPlayerPaymentSummary = `-- name: GetPlayerPaymentSummary :one
SELECT 
    player_id,
    COUNT(*) as total_payments,
    SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END) as total_paid,
    SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) as total_pending,
    SUM(CASE WHEN status = 'failed' THEN amount ELSE 0 END) as total_failed
FROM payments
WHERE player_id = $1
GROUP BY player_id
`

type GetPlayerPaymentSummaryRow struct {
	PlayerID      int64 `json:"playerId"`
	TotalPayments int64 `json:"totalPayments"`
	TotalPaid     int64 `json:"totalPaid"`
	TotalPending  int64 `json:"totalPending"`
	TotalFailed   int64 `json:"totalFailed"`
}

// GetPlayerPaymentSummary
//
//	SELECT
//	    player_id,
//	    COUNT(*) as total_payments,
//	    SUM(CASE WHEN status = 'completed' THEN amount ELSE 0 END) as total_paid,
//	    SUM(CASE WHEN status = 'pending' THEN amount ELSE 0 END) as total_pending,
//	    SUM(CASE WHEN status = 'failed' THEN amount ELSE 0 END) as total_failed
//	FROM payments
//	WHERE player_id = $1
//	GROUP BY player_id
func (q *Queries) GetPlayerPaymentSummary(ctx context.Context, playerID int64) (GetPlayerPaymentSummaryRow, error) {
	row := q.db.QueryRow(ctx, getPlayerPaymentSummary, playerID)
	var i GetPlayerPaymentSummaryRow
	err := row.Scan(
		&i.PlayerID,
		&i.TotalPayments,
		&i.TotalPaid,
		&i.TotalPending,
		&i.TotalFailed,
	)
	return i, err
}

const listPayments = `-- name: ListPayments :many
SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments
ORDER BY payment_date DESC
`

// ListPayments
//
//	SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments
//	ORDER BY payment_date DESC
func (q *Queries) ListPayments(ctx context.Context) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPayments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.TransactionID,
			&i.Amount,
			&i.Status,
			&i.PaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByPlayer = `-- name: ListPaymentsByPlayer :many
SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments
WHERE player_id = $1
ORDER BY payment_date DESC
`

// ListPaymentsByPlayer
//
//	SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments
//	WHERE player_id = $1
//	ORDER BY payment_date DESC
func (q *Queries) ListPaymentsByPlayer(ctx context.Context, playerID int64) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPaymentsByPlayer, playerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.TransactionID,
			&i.Amount,
			&i.Status,
			&i.PaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByStatus = `-- name: ListPaymentsByStatus :many
SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments
WHERE status = $1
ORDER BY payment_date DESC
`

// ListPaymentsByStatus
//
//	SELECT id, player_id, transaction_id, amount, status, payment_date FROM payments
//	WHERE status = $1
//	ORDER BY payment_date DESC
func (q *Queries) ListPaymentsByStatus(ctx context.Context, status string) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPaymentsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Payment{}
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.TransactionID,
			&i.Amount,
			&i.Status,
			&i.PaymentDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsWithPlayerInfo = `-- name: ListPaymentsWithPlayerInfo :many
SELECT py.id, py.player_id, py.transaction_id, py.amount, py.status, py.payment_date, p.user_id, u.first_name, u.last_name, u.email
FROM payments py
INNER JOIN players p ON py.player_id = p.id
INNER JOIN users u ON p.user_id = u.id
ORDER BY py.payment_date DESC
`

type ListPaymentsWithPlayerInfoRow struct {
	ID            int64            `json:"id"`
	PlayerID      int64            `json:"playerId"`
	TransactionID string           `json:"transactionId"`
	Amount        int32            `json:"amount"`
	Status        string           `json:"status"`
	PaymentDate   pgtype.Timestamp `json:"paymentDate"`
	UserID        int64            `json:"userId"`
	FirstName     string           `json:"firstName"`
	LastName      string           `json:"lastName"`
	Email         string           `json:"email"`
}

// ListPaymentsWithPlayerInfo
//
//	SELECT py.id, py.player_id, py.transaction_id, py.amount, py.status, py.payment_date, p.user_id, u.first_name, u.last_name, u.email
//	FROM payments py
//	INNER JOIN players p ON py.player_id = p.id
//	INNER JOIN users u ON p.user_id = u.id
//	ORDER BY py.payment_date DESC
func (q *Queries) ListPaymentsWithPlayerInfo(ctx context.Context) ([]ListPaymentsWithPlayerInfoRow, error) {
	rows, err := q.db.Query(ctx, listPaymentsWithPlayerInfo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPaymentsWithPlayerInfoRow{}
	for rows.Next() {
		var i ListPaymentsWithPlayerInfoRow
		if err := rows.Scan(
			&i.ID,
			&i.PlayerID,
			&i.TransactionID,
			&i.Amount,
			&i.Status,
			&i.PaymentDate,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :exec
UPDATE payments
SET status = $1
WHERE id = $2
`

type UpdatePaymentStatusParams struct {
	Status string `json:"status"`
	ID     int64  `json:"id"`
}

// UpdatePaymentStatus
//
//	UPDATE payments
//	SET status = $1
//	WHERE id = $2
func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) error {
	_, err := q.db.Exec(ctx, updatePaymentStatus, arg.Status, arg.ID)
	return err
}
