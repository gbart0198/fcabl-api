// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: players.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (user_id, team_id, fee_remainder, jersey_number, created_at, updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
RETURNING id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at
`

type CreatePlayerParams struct {
	UserID       int64       `json:"userId"`
	TeamID       pgtype.Int8 `json:"teamId"`
	FeeRemainder int32       `json:"feeRemainder"`
	JerseyNumber pgtype.Int4 `json:"jerseyNumber"`
}

// CreatePlayer
//
//	INSERT INTO players (user_id, team_id, fee_remainder, jersey_number, created_at, updated_at)
//	VALUES ($1, $2, $3, $4, NOW(), NOW())
//	RETURNING id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at
func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayer,
		arg.UserID,
		arg.TeamID,
		arg.FeeRemainder,
		arg.JerseyNumber,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.FeeRemainder,
		&i.JerseyNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePlayer = `-- name: DeletePlayer :exec
DELETE FROM players
WHERE id = $1
`

// DeletePlayer
//
//	DELETE FROM players
//	WHERE id = $1
func (q *Queries) DeletePlayer(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePlayer, id)
	return err
}

const getPlayerById = `-- name: GetPlayerById :one
SELECT id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at FROM players WHERE id = $1
`

// GetPlayerById
//
//	SELECT id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at FROM players WHERE id = $1
func (q *Queries) GetPlayerById(ctx context.Context, id int64) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerById, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.FeeRemainder,
		&i.JerseyNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerByUserId = `-- name: GetPlayerByUserId :one
SELECT id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at FROM players WHERE user_id = $1
`

// GetPlayerByUserId
//
//	SELECT id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at FROM players WHERE user_id = $1
func (q *Queries) GetPlayerByUserId(ctx context.Context, userID int64) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByUserId, userID)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.FeeRemainder,
		&i.JerseyNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerWithUserAndTeamInfo = `-- name: GetPlayerWithUserAndTeamInfo :one
SELECT p.id, p.user_id, p.team_id, t.name, p.jersey_number, u.first_name, u.last_name
FROM players p
INNER JOIN users u ON p.user_id = u.id
INNER JOIN teams t on t.id = p.team_id
WHERE p.id = $1
`

type GetPlayerWithUserAndTeamInfoRow struct {
	ID           int64       `json:"id"`
	UserID       int64       `json:"userId"`
	TeamID       pgtype.Int8 `json:"teamId"`
	Name         string      `json:"name"`
	JerseyNumber pgtype.Int4 `json:"jerseyNumber"`
	FirstName    string      `json:"firstName"`
	LastName     string      `json:"lastName"`
}

// GetPlayerWithUserAndTeamInfo
//
//	SELECT p.id, p.user_id, p.team_id, t.name, p.jersey_number, u.first_name, u.last_name
//	FROM players p
//	INNER JOIN users u ON p.user_id = u.id
//	INNER JOIN teams t on t.id = p.team_id
//	WHERE p.id = $1
func (q *Queries) GetPlayerWithUserAndTeamInfo(ctx context.Context, id int64) (GetPlayerWithUserAndTeamInfoRow, error) {
	row := q.db.QueryRow(ctx, getPlayerWithUserAndTeamInfo, id)
	var i GetPlayerWithUserAndTeamInfoRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.Name,
		&i.JerseyNumber,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getPlayerWithUserInfo = `-- name: GetPlayerWithUserInfo :one
SELECT p.id, p.user_id, p.team_id, p.jersey_number, u.first_name, u.last_name
FROM players p
INNER JOIN users u ON p.user_id = u.id
WHERE p.id = $1
`

type GetPlayerWithUserInfoRow struct {
	ID           int64       `json:"id"`
	UserID       int64       `json:"userId"`
	TeamID       pgtype.Int8 `json:"teamId"`
	JerseyNumber pgtype.Int4 `json:"jerseyNumber"`
	FirstName    string      `json:"firstName"`
	LastName     string      `json:"lastName"`
}

// GetPlayerWithUserInfo
//
//	SELECT p.id, p.user_id, p.team_id, p.jersey_number, u.first_name, u.last_name
//	FROM players p
//	INNER JOIN users u ON p.user_id = u.id
//	WHERE p.id = $1
func (q *Queries) GetPlayerWithUserInfo(ctx context.Context, id int64) (GetPlayerWithUserInfoRow, error) {
	row := q.db.QueryRow(ctx, getPlayerWithUserInfo, id)
	var i GetPlayerWithUserInfoRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.JerseyNumber,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getPlayerWithUserInfoDetailed = `-- name: GetPlayerWithUserInfoDetailed :one
SELECT p.id, p.user_id, p.team_id, p.fee_remainder, p.jersey_number, p.created_at, p.updated_at,
u.email, u.phone_number, u.first_name, u.last_name, u.role
FROM players p
INNER JOIN users u ON p.user_id = u.id
WHERE p.id = $1
`

type GetPlayerWithUserInfoDetailedRow struct {
	ID           int64            `json:"id"`
	UserID       int64            `json:"userId"`
	TeamID       pgtype.Int8      `json:"teamId"`
	FeeRemainder int32            `json:"feeRemainder"`
	JerseyNumber pgtype.Int4      `json:"jerseyNumber"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	Email        string           `json:"email"`
	PhoneNumber  string           `json:"phoneNumber"`
	FirstName    string           `json:"firstName"`
	LastName     string           `json:"lastName"`
	Role         string           `json:"role"`
}

// GetPlayerWithUserInfoDetailed
//
//	SELECT p.id, p.user_id, p.team_id, p.fee_remainder, p.jersey_number, p.created_at, p.updated_at,
//	u.email, u.phone_number, u.first_name, u.last_name, u.role
//	FROM players p
//	INNER JOIN users u ON p.user_id = u.id
//	WHERE p.id = $1
func (q *Queries) GetPlayerWithUserInfoDetailed(ctx context.Context, id int64) (GetPlayerWithUserInfoDetailedRow, error) {
	row := q.db.QueryRow(ctx, getPlayerWithUserInfoDetailed, id)
	var i GetPlayerWithUserInfoDetailedRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.FeeRemainder,
		&i.JerseyNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.PhoneNumber,
		&i.FirstName,
		&i.LastName,
		&i.Role,
	)
	return i, err
}

const listPlayers = `-- name: ListPlayers :many
SELECT id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at FROM players
ORDER BY id
`

// ListPlayers
//
//	SELECT id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at FROM players
//	ORDER BY id
func (q *Queries) ListPlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.db.Query(ctx, listPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.FeeRemainder,
			&i.JerseyNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayersByTeam = `-- name: ListPlayersByTeam :many
SELECT id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at FROM players
WHERE team_id = $1
ORDER BY jersey_number, id
`

// ListPlayersByTeam
//
//	SELECT id, user_id, team_id, fee_remainder, jersey_number, created_at, updated_at FROM players
//	WHERE team_id = $1
//	ORDER BY jersey_number, id
func (q *Queries) ListPlayersByTeam(ctx context.Context, teamID pgtype.Int8) ([]Player, error) {
	rows, err := q.db.Query(ctx, listPlayersByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.FeeRemainder,
			&i.JerseyNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayersWithUsers = `-- name: ListPlayersWithUsers :many
SELECT p.id, p.user_id, p.team_id, p.jersey_number, u.first_name, u.last_name
FROM players p
INNER JOIN users u ON p.user_id = u.id
ORDER BY u.last_name, u.first_name
`

type ListPlayersWithUsersRow struct {
	ID           int64       `json:"id"`
	UserID       int64       `json:"userId"`
	TeamID       pgtype.Int8 `json:"teamId"`
	JerseyNumber pgtype.Int4 `json:"jerseyNumber"`
	FirstName    string      `json:"firstName"`
	LastName     string      `json:"lastName"`
}

// ListPlayersWithUsers
//
//	SELECT p.id, p.user_id, p.team_id, p.jersey_number, u.first_name, u.last_name
//	FROM players p
//	INNER JOIN users u ON p.user_id = u.id
//	ORDER BY u.last_name, u.first_name
func (q *Queries) ListPlayersWithUsers(ctx context.Context) ([]ListPlayersWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listPlayersWithUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlayersWithUsersRow{}
	for rows.Next() {
		var i ListPlayersWithUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.JerseyNumber,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayersWithUsersDetailed = `-- name: ListPlayersWithUsersDetailed :many
SELECT p.id, p.user_id, p.team_id, p.fee_remainder, p.jersey_number, p.created_at, p.updated_at,
u.email, u.phone_number, u.first_name, u.last_name, u.role
FROM players p
INNER JOIN users u ON p.user_id = u.id
ORDER BY u.last_name, u.first_name
`

type ListPlayersWithUsersDetailedRow struct {
	ID           int64            `json:"id"`
	UserID       int64            `json:"userId"`
	TeamID       pgtype.Int8      `json:"teamId"`
	FeeRemainder int32            `json:"feeRemainder"`
	JerseyNumber pgtype.Int4      `json:"jerseyNumber"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	Email        string           `json:"email"`
	PhoneNumber  string           `json:"phoneNumber"`
	FirstName    string           `json:"firstName"`
	LastName     string           `json:"lastName"`
	Role         string           `json:"role"`
}

// ListPlayersWithUsersDetailed
//
//	SELECT p.id, p.user_id, p.team_id, p.fee_remainder, p.jersey_number, p.created_at, p.updated_at,
//	u.email, u.phone_number, u.first_name, u.last_name, u.role
//	FROM players p
//	INNER JOIN users u ON p.user_id = u.id
//	ORDER BY u.last_name, u.first_name
func (q *Queries) ListPlayersWithUsersDetailed(ctx context.Context) ([]ListPlayersWithUsersDetailedRow, error) {
	rows, err := q.db.Query(ctx, listPlayersWithUsersDetailed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlayersWithUsersDetailedRow{}
	for rows.Next() {
		var i ListPlayersWithUsersDetailedRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.FeeRemainder,
			&i.JerseyNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.PhoneNumber,
			&i.FirstName,
			&i.LastName,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayer = `-- name: UpdatePlayer :exec
UPDATE players
SET team_id = $1, fee_remainder = $2, jersey_number = $3, updated_at = NOW()
WHERE id = $4
`

type UpdatePlayerParams struct {
	TeamID       pgtype.Int8 `json:"teamId"`
	FeeRemainder int32       `json:"feeRemainder"`
	JerseyNumber pgtype.Int4 `json:"jerseyNumber"`
	ID           int64       `json:"id"`
}

// UpdatePlayer
//
//	UPDATE players
//	SET team_id = $1, fee_remainder = $2, jersey_number = $3, updated_at = NOW()
//	WHERE id = $4
func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) error {
	_, err := q.db.Exec(ctx, updatePlayer,
		arg.TeamID,
		arg.FeeRemainder,
		arg.JerseyNumber,
		arg.ID,
	)
	return err
}

const updatePlayerRegistrationFee = `-- name: UpdatePlayerRegistrationFee :exec
UPDATE players
SET fee_remainder = $1, updated_at = NOW()
WHERE id = $2
`

type UpdatePlayerRegistrationFeeParams struct {
	FeeRemainder int32 `json:"feeRemainder"`
	ID           int64 `json:"id"`
}

// UpdatePlayerRegistrationFee
//
//	UPDATE players
//	SET fee_remainder = $1, updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdatePlayerRegistrationFee(ctx context.Context, arg UpdatePlayerRegistrationFeeParams) error {
	_, err := q.db.Exec(ctx, updatePlayerRegistrationFee, arg.FeeRemainder, arg.ID)
	return err
}

const updatePlayerTeam = `-- name: UpdatePlayerTeam :exec
UPDATE players
SET team_id = $1, updated_at = NOW()
WHERE id = $2
`

type UpdatePlayerTeamParams struct {
	TeamID pgtype.Int8 `json:"teamId"`
	ID     int64       `json:"id"`
}

// UpdatePlayerTeam
//
//	UPDATE players
//	SET team_id = $1, updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdatePlayerTeam(ctx context.Context, arg UpdatePlayerTeamParams) error {
	_, err := q.db.Exec(ctx, updatePlayerTeam, arg.TeamID, arg.ID)
	return err
}
