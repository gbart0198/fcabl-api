// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: players.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at
`

type CreatePlayerParams struct {
	UserID             int64          `json:"userId"`
	TeamID             pgtype.Int8    `json:"teamId"`
	RegistrationFeeDue pgtype.Numeric `json:"registrationFeeDue"`
	IsFullyRegistered  bool           `json:"isFullyRegistered"`
	IsActive           bool           `json:"isActive"`
	JerseyNumber       pgtype.Int4    `json:"jerseyNumber"`
}

// CreatePlayer
//
//	INSERT INTO players (user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at)
//	VALUES ($1, $2, $3, $4, $5, $6, NOW(), NOW())
//	RETURNING id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at
func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayer,
		arg.UserID,
		arg.TeamID,
		arg.RegistrationFeeDue,
		arg.IsFullyRegistered,
		arg.IsActive,
		arg.JerseyNumber,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.RegistrationFeeDue,
		&i.IsFullyRegistered,
		&i.IsActive,
		&i.JerseyNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePlayer = `-- name: DeletePlayer :exec
DELETE FROM players
WHERE id = $1
`

// DeletePlayer
//
//	DELETE FROM players
//	WHERE id = $1
func (q *Queries) DeletePlayer(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePlayer, id)
	return err
}

const getPlayerById = `-- name: GetPlayerById :one
SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players WHERE id = $1
`

// GetPlayerById
//
//	SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players WHERE id = $1
func (q *Queries) GetPlayerById(ctx context.Context, id int64) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerById, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.RegistrationFeeDue,
		&i.IsFullyRegistered,
		&i.IsActive,
		&i.JerseyNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerByUserId = `-- name: GetPlayerByUserId :one
SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players WHERE user_id = $1
`

// GetPlayerByUserId
//
//	SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players WHERE user_id = $1
func (q *Queries) GetPlayerByUserId(ctx context.Context, userID int64) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByUserId, userID)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.RegistrationFeeDue,
		&i.IsFullyRegistered,
		&i.IsActive,
		&i.JerseyNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerWithTeam = `-- name: GetPlayerWithTeam :one
SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered, p.is_active, p.jersey_number, p.created_at, p.updated_at, t.name as team_name
FROM players p
LEFT JOIN teams t ON p.team_id = t.id
WHERE p.id = $1
`

type GetPlayerWithTeamRow struct {
	ID                 int64            `json:"id"`
	UserID             int64            `json:"userId"`
	TeamID             pgtype.Int8      `json:"teamId"`
	RegistrationFeeDue pgtype.Numeric   `json:"registrationFeeDue"`
	IsFullyRegistered  bool             `json:"isFullyRegistered"`
	IsActive           bool             `json:"isActive"`
	JerseyNumber       pgtype.Int4      `json:"jerseyNumber"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	TeamName           pgtype.Text      `json:"teamName"`
}

// GetPlayerWithTeam
//
//	SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered, p.is_active, p.jersey_number, p.created_at, p.updated_at, t.name as team_name
//	FROM players p
//	LEFT JOIN teams t ON p.team_id = t.id
//	WHERE p.id = $1
func (q *Queries) GetPlayerWithTeam(ctx context.Context, id int64) (GetPlayerWithTeamRow, error) {
	row := q.db.QueryRow(ctx, getPlayerWithTeam, id)
	var i GetPlayerWithTeamRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.RegistrationFeeDue,
		&i.IsFullyRegistered,
		&i.IsActive,
		&i.JerseyNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TeamName,
	)
	return i, err
}

const getPlayerWithUser = `-- name: GetPlayerWithUser :one
SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered, p.is_active, p.jersey_number, p.created_at, p.updated_at, u.email, u.phone_number, u.first_name, u.last_name, u.role
FROM players p
INNER JOIN users u ON p.user_id = u.id
WHERE p.id = $1
`

type GetPlayerWithUserRow struct {
	ID                 int64            `json:"id"`
	UserID             int64            `json:"userId"`
	TeamID             pgtype.Int8      `json:"teamId"`
	RegistrationFeeDue pgtype.Numeric   `json:"registrationFeeDue"`
	IsFullyRegistered  bool             `json:"isFullyRegistered"`
	IsActive           bool             `json:"isActive"`
	JerseyNumber       pgtype.Int4      `json:"jerseyNumber"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	Email              string           `json:"email"`
	PhoneNumber        string           `json:"phoneNumber"`
	FirstName          string           `json:"firstName"`
	LastName           string           `json:"lastName"`
	Role               string           `json:"role"`
}

// GetPlayerWithUser
//
//	SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered, p.is_active, p.jersey_number, p.created_at, p.updated_at, u.email, u.phone_number, u.first_name, u.last_name, u.role
//	FROM players p
//	INNER JOIN users u ON p.user_id = u.id
//	WHERE p.id = $1
func (q *Queries) GetPlayerWithUser(ctx context.Context, id int64) (GetPlayerWithUserRow, error) {
	row := q.db.QueryRow(ctx, getPlayerWithUser, id)
	var i GetPlayerWithUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.RegistrationFeeDue,
		&i.IsFullyRegistered,
		&i.IsActive,
		&i.JerseyNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Email,
		&i.PhoneNumber,
		&i.FirstName,
		&i.LastName,
		&i.Role,
	)
	return i, err
}

const listActivePlayers = `-- name: ListActivePlayers :many
SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players
WHERE is_active = true
ORDER BY id
`

// ListActivePlayers
//
//	SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players
//	WHERE is_active = true
//	ORDER BY id
func (q *Queries) ListActivePlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.db.Query(ctx, listActivePlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.RegistrationFeeDue,
			&i.IsFullyRegistered,
			&i.IsActive,
			&i.JerseyNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFreeAgents = `-- name: ListFreeAgents :many
SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered, p.is_active, p.jersey_number, p.created_at, p.updated_at, u.email, u.first_name, u.last_name
FROM players p
INNER JOIN users u ON p.user_id = u.id
WHERE p.team_id IS NULL AND p.is_active = true
ORDER BY u.last_name, u.first_name
`

type ListFreeAgentsRow struct {
	ID                 int64            `json:"id"`
	UserID             int64            `json:"userId"`
	TeamID             pgtype.Int8      `json:"teamId"`
	RegistrationFeeDue pgtype.Numeric   `json:"registrationFeeDue"`
	IsFullyRegistered  bool             `json:"isFullyRegistered"`
	IsActive           bool             `json:"isActive"`
	JerseyNumber       pgtype.Int4      `json:"jerseyNumber"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	Email              string           `json:"email"`
	FirstName          string           `json:"firstName"`
	LastName           string           `json:"lastName"`
}

// ListFreeAgents
//
//	SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered, p.is_active, p.jersey_number, p.created_at, p.updated_at, u.email, u.first_name, u.last_name
//	FROM players p
//	INNER JOIN users u ON p.user_id = u.id
//	WHERE p.team_id IS NULL AND p.is_active = true
//	ORDER BY u.last_name, u.first_name
func (q *Queries) ListFreeAgents(ctx context.Context) ([]ListFreeAgentsRow, error) {
	rows, err := q.db.Query(ctx, listFreeAgents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFreeAgentsRow{}
	for rows.Next() {
		var i ListFreeAgentsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.RegistrationFeeDue,
			&i.IsFullyRegistered,
			&i.IsActive,
			&i.JerseyNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayers = `-- name: ListPlayers :many
SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players
ORDER BY id
`

// ListPlayers
//
//	SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players
//	ORDER BY id
func (q *Queries) ListPlayers(ctx context.Context) ([]Player, error) {
	rows, err := q.db.Query(ctx, listPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.RegistrationFeeDue,
			&i.IsFullyRegistered,
			&i.IsActive,
			&i.JerseyNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayersByTeam = `-- name: ListPlayersByTeam :many
SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players
WHERE team_id = $1
ORDER BY jersey_number, id
`

// ListPlayersByTeam
//
//	SELECT id, user_id, team_id, registration_fee_due, is_fully_registered, is_active, jersey_number, created_at, updated_at FROM players
//	WHERE team_id = $1
//	ORDER BY jersey_number, id
func (q *Queries) ListPlayersByTeam(ctx context.Context, teamID pgtype.Int8) ([]Player, error) {
	rows, err := q.db.Query(ctx, listPlayersByTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.RegistrationFeeDue,
			&i.IsFullyRegistered,
			&i.IsActive,
			&i.JerseyNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPlayersWithUsers = `-- name: ListPlayersWithUsers :many
SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered, p.is_active, p.jersey_number, p.created_at, p.updated_at, u.email, u.first_name, u.last_name
FROM players p
INNER JOIN users u ON p.user_id = u.id
ORDER BY u.last_name, u.first_name
`

type ListPlayersWithUsersRow struct {
	ID                 int64            `json:"id"`
	UserID             int64            `json:"userId"`
	TeamID             pgtype.Int8      `json:"teamId"`
	RegistrationFeeDue pgtype.Numeric   `json:"registrationFeeDue"`
	IsFullyRegistered  bool             `json:"isFullyRegistered"`
	IsActive           bool             `json:"isActive"`
	JerseyNumber       pgtype.Int4      `json:"jerseyNumber"`
	CreatedAt          pgtype.Timestamp `json:"createdAt"`
	UpdatedAt          pgtype.Timestamp `json:"updatedAt"`
	Email              string           `json:"email"`
	FirstName          string           `json:"firstName"`
	LastName           string           `json:"lastName"`
}

// ListPlayersWithUsers
//
//	SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered, p.is_active, p.jersey_number, p.created_at, p.updated_at, u.email, u.first_name, u.last_name
//	FROM players p
//	INNER JOIN users u ON p.user_id = u.id
//	ORDER BY u.last_name, u.first_name
func (q *Queries) ListPlayersWithUsers(ctx context.Context) ([]ListPlayersWithUsersRow, error) {
	rows, err := q.db.Query(ctx, listPlayersWithUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPlayersWithUsersRow{}
	for rows.Next() {
		var i ListPlayersWithUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.RegistrationFeeDue,
			&i.IsFullyRegistered,
			&i.IsActive,
			&i.JerseyNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Email,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayer = `-- name: UpdatePlayer :exec
UPDATE players
SET team_id = $1, registration_fee_due = $2, is_fully_registered = $3, 
    is_active = $4, jersey_number = $5, updated_at = NOW()
WHERE id = $6
`

type UpdatePlayerParams struct {
	TeamID             pgtype.Int8    `json:"teamId"`
	RegistrationFeeDue pgtype.Numeric `json:"registrationFeeDue"`
	IsFullyRegistered  bool           `json:"isFullyRegistered"`
	IsActive           bool           `json:"isActive"`
	JerseyNumber       pgtype.Int4    `json:"jerseyNumber"`
	ID                 int64          `json:"id"`
}

// UpdatePlayer
//
//	UPDATE players
//	SET team_id = $1, registration_fee_due = $2, is_fully_registered = $3,
//	    is_active = $4, jersey_number = $5, updated_at = NOW()
//	WHERE id = $6
func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) error {
	_, err := q.db.Exec(ctx, updatePlayer,
		arg.TeamID,
		arg.RegistrationFeeDue,
		arg.IsFullyRegistered,
		arg.IsActive,
		arg.JerseyNumber,
		arg.ID,
	)
	return err
}

const updatePlayerRegistrationStatus = `-- name: UpdatePlayerRegistrationStatus :exec
UPDATE players
SET registration_fee_due = $1, is_fully_registered = $2, updated_at = NOW()
WHERE id = $3
`

type UpdatePlayerRegistrationStatusParams struct {
	RegistrationFeeDue pgtype.Numeric `json:"registrationFeeDue"`
	IsFullyRegistered  bool           `json:"isFullyRegistered"`
	ID                 int64          `json:"id"`
}

// UpdatePlayerRegistrationStatus
//
//	UPDATE players
//	SET registration_fee_due = $1, is_fully_registered = $2, updated_at = NOW()
//	WHERE id = $3
func (q *Queries) UpdatePlayerRegistrationStatus(ctx context.Context, arg UpdatePlayerRegistrationStatusParams) error {
	_, err := q.db.Exec(ctx, updatePlayerRegistrationStatus, arg.RegistrationFeeDue, arg.IsFullyRegistered, arg.ID)
	return err
}

const updatePlayerTeam = `-- name: UpdatePlayerTeam :exec
UPDATE players
SET team_id = $1, updated_at = NOW()
WHERE id = $2
`

type UpdatePlayerTeamParams struct {
	TeamID pgtype.Int8 `json:"teamId"`
	ID     int64       `json:"id"`
}

// UpdatePlayerTeam
//
//	UPDATE players
//	SET team_id = $1, updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdatePlayerTeam(ctx context.Context, arg UpdatePlayerTeamParams) error {
	_, err := q.db.Exec(ctx, updatePlayerTeam, arg.TeamID, arg.ID)
	return err
}
