// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGame = `-- name: CreateGame :one
INSERT INTO games (home_team_id, away_team_id, game_time, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, home_team_id, away_team_id, game_time, created_at, updated_at
`

type CreateGameParams struct {
	HomeTeamID int64            `json:"homeTeamId"`
	AwayTeamID int64            `json:"awayTeamId"`
	GameTime   pgtype.Timestamp `json:"gameTime"`
}

// CreateGame
//
//	INSERT INTO games (home_team_id, away_team_id, game_time, created_at, updated_at)
//	VALUES ($1, $2, $3, NOW(), NOW())
//	RETURNING id, home_team_id, away_team_id, game_time, created_at, updated_at
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, createGame, arg.HomeTeamID, arg.AwayTeamID, arg.GameTime)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.GameTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGame = `-- name: DeleteGame :exec
DELETE FROM games
WHERE id = $1
`

// DeleteGame
//
//	DELETE FROM games
//	WHERE id = $1
func (q *Queries) DeleteGame(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteGame, id)
	return err
}

const getGameById = `-- name: GetGameById :one
SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games WHERE id = $1
`

// GetGameById
//
//	SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games WHERE id = $1
func (q *Queries) GetGameById(ctx context.Context, id int64) (Game, error) {
	row := q.db.QueryRow(ctx, getGameById, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.GameTime,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGameWithResult = `-- name: GetGameWithResult :one
SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at, gr.home_score, gr.away_score, gr.winning_team_id, gr.recorded_at
FROM games g
LEFT JOIN game_results gr ON g.id = gr.game_id
WHERE g.id = $1
`

type GetGameWithResultRow struct {
	ID            int64            `json:"id"`
	HomeTeamID    int64            `json:"homeTeamId"`
	AwayTeamID    int64            `json:"awayTeamId"`
	GameTime      pgtype.Timestamp `json:"gameTime"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	HomeScore     pgtype.Int4      `json:"homeScore"`
	AwayScore     pgtype.Int4      `json:"awayScore"`
	WinningTeamID pgtype.Int8      `json:"winningTeamId"`
	RecordedAt    pgtype.Timestamp `json:"recordedAt"`
}

// GetGameWithResult
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at, gr.home_score, gr.away_score, gr.winning_team_id, gr.recorded_at
//	FROM games g
//	LEFT JOIN game_results gr ON g.id = gr.game_id
//	WHERE g.id = $1
func (q *Queries) GetGameWithResult(ctx context.Context, id int64) (GetGameWithResultRow, error) {
	row := q.db.QueryRow(ctx, getGameWithResult, id)
	var i GetGameWithResultRow
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.GameTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HomeScore,
		&i.AwayScore,
		&i.WinningTeamID,
		&i.RecordedAt,
	)
	return i, err
}

const getGameWithTeams = `-- name: GetGameWithTeams :one
SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at, 
       ht.name as home_team_name, ht.wins as home_team_wins, ht.losses as home_team_losses,
       at.name as away_team_name, at.wins as away_team_wins, at.losses as away_team_losses
FROM games g
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
WHERE g.id = $1
`

type GetGameWithTeamsRow struct {
	ID             int64            `json:"id"`
	HomeTeamID     int64            `json:"homeTeamId"`
	AwayTeamID     int64            `json:"awayTeamId"`
	GameTime       pgtype.Timestamp `json:"gameTime"`
	CreatedAt      pgtype.Timestamp `json:"createdAt"`
	UpdatedAt      pgtype.Timestamp `json:"updatedAt"`
	HomeTeamName   string           `json:"homeTeamName"`
	HomeTeamWins   int32            `json:"homeTeamWins"`
	HomeTeamLosses int32            `json:"homeTeamLosses"`
	AwayTeamName   string           `json:"awayTeamName"`
	AwayTeamWins   int32            `json:"awayTeamWins"`
	AwayTeamLosses int32            `json:"awayTeamLosses"`
}

// GetGameWithTeams
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at,
//	       ht.name as home_team_name, ht.wins as home_team_wins, ht.losses as home_team_losses,
//	       at.name as away_team_name, at.wins as away_team_wins, at.losses as away_team_losses
//	FROM games g
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	WHERE g.id = $1
func (q *Queries) GetGameWithTeams(ctx context.Context, id int64) (GetGameWithTeamsRow, error) {
	row := q.db.QueryRow(ctx, getGameWithTeams, id)
	var i GetGameWithTeamsRow
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.GameTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.HomeTeamName,
		&i.HomeTeamWins,
		&i.HomeTeamLosses,
		&i.AwayTeamName,
		&i.AwayTeamWins,
		&i.AwayTeamLosses,
	)
	return i, err
}

const listGames = `-- name: ListGames :many
SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games
ORDER BY game_time
`

// ListGames
//
//	SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games
//	ORDER BY game_time
func (q *Queries) ListGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, listGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGamesByTeam = `-- name: ListGamesByTeam :many
SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games
WHERE home_team_id = $1 OR away_team_id = $1
ORDER BY game_time
`

// ListGamesByTeam
//
//	SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games
//	WHERE home_team_id = $1 OR away_team_id = $1
//	ORDER BY game_time
func (q *Queries) ListGamesByTeam(ctx context.Context, homeTeamID int64) ([]Game, error) {
	rows, err := q.db.Query(ctx, listGamesByTeam, homeTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGamesWithResults = `-- name: ListGamesWithResults :many
SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at, 
       ht.name as home_team_name,
       at.name as away_team_name,
       gr.home_score, gr.away_score, gr.winning_team_id
FROM games g
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
LEFT JOIN game_results gr ON g.id = gr.game_id
ORDER BY g.game_time DESC
`

type ListGamesWithResultsRow struct {
	ID            int64            `json:"id"`
	HomeTeamID    int64            `json:"homeTeamId"`
	AwayTeamID    int64            `json:"awayTeamId"`
	GameTime      pgtype.Timestamp `json:"gameTime"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	HomeTeamName  string           `json:"homeTeamName"`
	AwayTeamName  string           `json:"awayTeamName"`
	HomeScore     pgtype.Int4      `json:"homeScore"`
	AwayScore     pgtype.Int4      `json:"awayScore"`
	WinningTeamID pgtype.Int8      `json:"winningTeamId"`
}

// ListGamesWithResults
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at,
//	       ht.name as home_team_name,
//	       at.name as away_team_name,
//	       gr.home_score, gr.away_score, gr.winning_team_id
//	FROM games g
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	LEFT JOIN game_results gr ON g.id = gr.game_id
//	ORDER BY g.game_time DESC
func (q *Queries) ListGamesWithResults(ctx context.Context) ([]ListGamesWithResultsRow, error) {
	rows, err := q.db.Query(ctx, listGamesWithResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGamesWithResultsRow{}
	for rows.Next() {
		var i ListGamesWithResultsRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.HomeScore,
			&i.AwayScore,
			&i.WinningTeamID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGamesWithTeams = `-- name: ListGamesWithTeams :many
SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at, 
       ht.name as home_team_name,
       at.name as away_team_name
FROM games g
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
ORDER BY g.game_time
`

type ListGamesWithTeamsRow struct {
	ID           int64            `json:"id"`
	HomeTeamID   int64            `json:"homeTeamId"`
	AwayTeamID   int64            `json:"awayTeamId"`
	GameTime     pgtype.Timestamp `json:"gameTime"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	HomeTeamName string           `json:"homeTeamName"`
	AwayTeamName string           `json:"awayTeamName"`
}

// ListGamesWithTeams
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at,
//	       ht.name as home_team_name,
//	       at.name as away_team_name
//	FROM games g
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	ORDER BY g.game_time
func (q *Queries) ListGamesWithTeams(ctx context.Context) ([]ListGamesWithTeamsRow, error) {
	rows, err := q.db.Query(ctx, listGamesWithTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGamesWithTeamsRow{}
	for rows.Next() {
		var i ListGamesWithTeamsRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HomeTeamName,
			&i.AwayTeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPastGames = `-- name: ListPastGames :many
SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games
WHERE game_time <= NOW()
ORDER BY game_time DESC
`

// ListPastGames
//
//	SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games
//	WHERE game_time <= NOW()
//	ORDER BY game_time DESC
func (q *Queries) ListPastGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, listPastGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamSchedule = `-- name: ListTeamSchedule :many
SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at, 
       ht.name as home_team_name,
       at.name as away_team_name,
       CASE 
           WHEN g.home_team_id = $1 THEN 'HOME'
           WHEN g.away_team_id = $1 THEN 'AWAY'
       END as team_location
FROM games g
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
WHERE g.home_team_id = $1 OR g.away_team_id = $1
ORDER BY g.game_time
`

type ListTeamScheduleRow struct {
	ID           int64            `json:"id"`
	HomeTeamID   int64            `json:"homeTeamId"`
	AwayTeamID   int64            `json:"awayTeamId"`
	GameTime     pgtype.Timestamp `json:"gameTime"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	HomeTeamName string           `json:"homeTeamName"`
	AwayTeamName string           `json:"awayTeamName"`
	TeamLocation interface{}      `json:"teamLocation"`
}

// ListTeamSchedule
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.game_time, g.created_at, g.updated_at,
//	       ht.name as home_team_name,
//	       at.name as away_team_name,
//	       CASE
//	           WHEN g.home_team_id = $1 THEN 'HOME'
//	           WHEN g.away_team_id = $1 THEN 'AWAY'
//	       END as team_location
//	FROM games g
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	WHERE g.home_team_id = $1 OR g.away_team_id = $1
//	ORDER BY g.game_time
func (q *Queries) ListTeamSchedule(ctx context.Context, homeTeamID int64) ([]ListTeamScheduleRow, error) {
	rows, err := q.db.Query(ctx, listTeamSchedule, homeTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTeamScheduleRow{}
	for rows.Next() {
		var i ListTeamScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.TeamLocation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingGames = `-- name: ListUpcomingGames :many
SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games
WHERE game_time > NOW()
ORDER BY game_time
`

// ListUpcomingGames
//
//	SELECT id, home_team_id, away_team_id, game_time, created_at, updated_at FROM games
//	WHERE game_time > NOW()
//	ORDER BY game_time
func (q *Queries) ListUpcomingGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, listUpcomingGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGame = `-- name: UpdateGame :exec
UPDATE games
SET home_team_id = $1, away_team_id = $2, game_time = $3, updated_at = NOW()
WHERE id = $4
`

type UpdateGameParams struct {
	HomeTeamID int64            `json:"homeTeamId"`
	AwayTeamID int64            `json:"awayTeamId"`
	GameTime   pgtype.Timestamp `json:"gameTime"`
	ID         int64            `json:"id"`
}

// UpdateGame
//
//	UPDATE games
//	SET home_team_id = $1, away_team_id = $2, game_time = $3, updated_at = NOW()
//	WHERE id = $4
func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) error {
	_, err := q.db.Exec(ctx, updateGame,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.GameTime,
		arg.ID,
	)
	return err
}

const updateGameTime = `-- name: UpdateGameTime :exec
UPDATE games
SET game_time = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateGameTimeParams struct {
	GameTime pgtype.Timestamp `json:"gameTime"`
	ID       int64            `json:"id"`
}

// UpdateGameTime
//
//	UPDATE games
//	SET game_time = $1, updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateGameTime(ctx context.Context, arg UpdateGameTimeParams) error {
	_, err := q.db.Exec(ctx, updateGameTime, arg.GameTime, arg.ID)
	return err
}
