// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: game_results.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGameResult = `-- name: CreateGameResult :one
INSERT INTO game_results (game_id, home_score, away_score, winning_team_id, recorded_at)
VALUES ($1, $2, $3, $4, NOW())
RETURNING id, game_id, home_score, away_score, winning_team_id, recorded_at
`

type CreateGameResultParams struct {
	GameID        int64       `json:"gameId"`
	HomeScore     int32       `json:"homeScore"`
	AwayScore     int32       `json:"awayScore"`
	WinningTeamID pgtype.Int8 `json:"winningTeamId"`
}

// CreateGameResult
//
//	INSERT INTO game_results (game_id, home_score, away_score, winning_team_id, recorded_at)
//	VALUES ($1, $2, $3, $4, NOW())
//	RETURNING id, game_id, home_score, away_score, winning_team_id, recorded_at
func (q *Queries) CreateGameResult(ctx context.Context, arg CreateGameResultParams) (GameResult, error) {
	row := q.db.QueryRow(ctx, createGameResult,
		arg.GameID,
		arg.HomeScore,
		arg.AwayScore,
		arg.WinningTeamID,
	)
	var i GameResult
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.HomeScore,
		&i.AwayScore,
		&i.WinningTeamID,
		&i.RecordedAt,
	)
	return i, err
}

const deleteGameResult = `-- name: DeleteGameResult :exec
DELETE FROM game_results
WHERE id = $1
`

// DeleteGameResult
//
//	DELETE FROM game_results
//	WHERE id = $1
func (q *Queries) DeleteGameResult(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteGameResult, id)
	return err
}

const getGameResultByGameId = `-- name: GetGameResultByGameId :one
SELECT id, game_id, home_score, away_score, winning_team_id, recorded_at FROM game_results WHERE game_id = $1
`

// GetGameResultByGameId
//
//	SELECT id, game_id, home_score, away_score, winning_team_id, recorded_at FROM game_results WHERE game_id = $1
func (q *Queries) GetGameResultByGameId(ctx context.Context, gameID int64) (GameResult, error) {
	row := q.db.QueryRow(ctx, getGameResultByGameId, gameID)
	var i GameResult
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.HomeScore,
		&i.AwayScore,
		&i.WinningTeamID,
		&i.RecordedAt,
	)
	return i, err
}

const getGameResultById = `-- name: GetGameResultById :one
SELECT id, game_id, home_score, away_score, winning_team_id, recorded_at FROM game_results WHERE id = $1
`

// GetGameResultById
//
//	SELECT id, game_id, home_score, away_score, winning_team_id, recorded_at FROM game_results WHERE id = $1
func (q *Queries) GetGameResultById(ctx context.Context, id int64) (GameResult, error) {
	row := q.db.QueryRow(ctx, getGameResultById, id)
	var i GameResult
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.HomeScore,
		&i.AwayScore,
		&i.WinningTeamID,
		&i.RecordedAt,
	)
	return i, err
}

const getGameResultWithTeams = `-- name: GetGameResultWithTeams :one
SELECT gr.id, gr.game_id, gr.home_score, gr.away_score, gr.winning_team_id, gr.recorded_at, g.game_time,
       ht.name as home_team_name,
       at.name as away_team_name,
       wt.name as winning_team_name
FROM game_results gr
INNER JOIN games g ON gr.game_id = g.id
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
LEFT JOIN teams wt ON gr.winning_team_id = wt.id
WHERE gr.id = $1
`

type GetGameResultWithTeamsRow struct {
	ID              int64            `json:"id"`
	GameID          int64            `json:"gameId"`
	HomeScore       int32            `json:"homeScore"`
	AwayScore       int32            `json:"awayScore"`
	WinningTeamID   pgtype.Int8      `json:"winningTeamId"`
	RecordedAt      pgtype.Timestamp `json:"recordedAt"`
	GameTime        pgtype.Timestamp `json:"gameTime"`
	HomeTeamName    string           `json:"homeTeamName"`
	AwayTeamName    string           `json:"awayTeamName"`
	WinningTeamName pgtype.Text      `json:"winningTeamName"`
}

// GetGameResultWithTeams
//
//	SELECT gr.id, gr.game_id, gr.home_score, gr.away_score, gr.winning_team_id, gr.recorded_at, g.game_time,
//	       ht.name as home_team_name,
//	       at.name as away_team_name,
//	       wt.name as winning_team_name
//	FROM game_results gr
//	INNER JOIN games g ON gr.game_id = g.id
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	LEFT JOIN teams wt ON gr.winning_team_id = wt.id
//	WHERE gr.id = $1
func (q *Queries) GetGameResultWithTeams(ctx context.Context, id int64) (GetGameResultWithTeamsRow, error) {
	row := q.db.QueryRow(ctx, getGameResultWithTeams, id)
	var i GetGameResultWithTeamsRow
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.HomeScore,
		&i.AwayScore,
		&i.WinningTeamID,
		&i.RecordedAt,
		&i.GameTime,
		&i.HomeTeamName,
		&i.AwayTeamName,
		&i.WinningTeamName,
	)
	return i, err
}

const getTeamRecord = `-- name: GetTeamRecord :one
SELECT 
    COUNT(*) as games_played,
    SUM(CASE WHEN gr.winning_team_id = $1 THEN 1 ELSE 0 END) as wins,
    SUM(CASE WHEN gr.winning_team_id IS NULL THEN 1 ELSE 0 END) as draws,
    SUM(CASE WHEN gr.winning_team_id IS NOT NULL AND gr.winning_team_id != $1 THEN 1 ELSE 0 END) as losses,
    SUM(CASE 
        WHEN g.home_team_id = $1 THEN gr.home_score
        WHEN g.away_team_id = $1 THEN gr.away_score
        ELSE 0
    END) as points_for,
    SUM(CASE 
        WHEN g.home_team_id = $1 THEN gr.away_score
        WHEN g.away_team_id = $1 THEN gr.home_score
        ELSE 0
    END) as points_against
FROM game_results gr
INNER JOIN games g ON gr.game_id = g.id
WHERE g.home_team_id = $1 OR g.away_team_id = $1
`

type GetTeamRecordRow struct {
	GamesPlayed   int64 `json:"gamesPlayed"`
	Wins          int64 `json:"wins"`
	Draws         int64 `json:"draws"`
	Losses        int64 `json:"losses"`
	PointsFor     int64 `json:"pointsFor"`
	PointsAgainst int64 `json:"pointsAgainst"`
}

// GetTeamRecord
//
//	SELECT
//	    COUNT(*) as games_played,
//	    SUM(CASE WHEN gr.winning_team_id = $1 THEN 1 ELSE 0 END) as wins,
//	    SUM(CASE WHEN gr.winning_team_id IS NULL THEN 1 ELSE 0 END) as draws,
//	    SUM(CASE WHEN gr.winning_team_id IS NOT NULL AND gr.winning_team_id != $1 THEN 1 ELSE 0 END) as losses,
//	    SUM(CASE
//	        WHEN g.home_team_id = $1 THEN gr.home_score
//	        WHEN g.away_team_id = $1 THEN gr.away_score
//	        ELSE 0
//	    END) as points_for,
//	    SUM(CASE
//	        WHEN g.home_team_id = $1 THEN gr.away_score
//	        WHEN g.away_team_id = $1 THEN gr.home_score
//	        ELSE 0
//	    END) as points_against
//	FROM game_results gr
//	INNER JOIN games g ON gr.game_id = g.id
//	WHERE g.home_team_id = $1 OR g.away_team_id = $1
func (q *Queries) GetTeamRecord(ctx context.Context, winningTeamID pgtype.Int8) (GetTeamRecordRow, error) {
	row := q.db.QueryRow(ctx, getTeamRecord, winningTeamID)
	var i GetTeamRecordRow
	err := row.Scan(
		&i.GamesPlayed,
		&i.Wins,
		&i.Draws,
		&i.Losses,
		&i.PointsFor,
		&i.PointsAgainst,
	)
	return i, err
}

const listGameResults = `-- name: ListGameResults :many
SELECT id, game_id, home_score, away_score, winning_team_id, recorded_at FROM game_results
ORDER BY recorded_at DESC
`

// ListGameResults
//
//	SELECT id, game_id, home_score, away_score, winning_team_id, recorded_at FROM game_results
//	ORDER BY recorded_at DESC
func (q *Queries) ListGameResults(ctx context.Context) ([]GameResult, error) {
	rows, err := q.db.Query(ctx, listGameResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GameResult{}
	for rows.Next() {
		var i GameResult
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.HomeScore,
			&i.AwayScore,
			&i.WinningTeamID,
			&i.RecordedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGameResultsWithTeams = `-- name: ListGameResultsWithTeams :many
SELECT gr.id, gr.game_id, gr.home_score, gr.away_score, gr.winning_team_id, gr.recorded_at, g.game_time,
       ht.name as home_team_name,
       at.name as away_team_name,
       wt.name as winning_team_name
FROM game_results gr
INNER JOIN games g ON gr.game_id = g.id
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
LEFT JOIN teams wt ON gr.winning_team_id = wt.id
ORDER BY gr.recorded_at DESC
`

type ListGameResultsWithTeamsRow struct {
	ID              int64            `json:"id"`
	GameID          int64            `json:"gameId"`
	HomeScore       int32            `json:"homeScore"`
	AwayScore       int32            `json:"awayScore"`
	WinningTeamID   pgtype.Int8      `json:"winningTeamId"`
	RecordedAt      pgtype.Timestamp `json:"recordedAt"`
	GameTime        pgtype.Timestamp `json:"gameTime"`
	HomeTeamName    string           `json:"homeTeamName"`
	AwayTeamName    string           `json:"awayTeamName"`
	WinningTeamName pgtype.Text      `json:"winningTeamName"`
}

// ListGameResultsWithTeams
//
//	SELECT gr.id, gr.game_id, gr.home_score, gr.away_score, gr.winning_team_id, gr.recorded_at, g.game_time,
//	       ht.name as home_team_name,
//	       at.name as away_team_name,
//	       wt.name as winning_team_name
//	FROM game_results gr
//	INNER JOIN games g ON gr.game_id = g.id
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	LEFT JOIN teams wt ON gr.winning_team_id = wt.id
//	ORDER BY gr.recorded_at DESC
func (q *Queries) ListGameResultsWithTeams(ctx context.Context) ([]ListGameResultsWithTeamsRow, error) {
	rows, err := q.db.Query(ctx, listGameResultsWithTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGameResultsWithTeamsRow{}
	for rows.Next() {
		var i ListGameResultsWithTeamsRow
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.HomeScore,
			&i.AwayScore,
			&i.WinningTeamID,
			&i.RecordedAt,
			&i.GameTime,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.WinningTeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamGameResults = `-- name: ListTeamGameResults :many
SELECT gr.id, gr.game_id, gr.home_score, gr.away_score, gr.winning_team_id, gr.recorded_at, g.game_time, g.home_team_id, g.away_team_id,
       ht.name as home_team_name,
       at.name as away_team_name,
       CASE 
           WHEN g.home_team_id = $1 THEN gr.home_score
           WHEN g.away_team_id = $1 THEN gr.away_score
       END as team_score,
       CASE 
           WHEN g.home_team_id = $1 THEN gr.away_score
           WHEN g.away_team_id = $1 THEN gr.home_score
       END as opponent_score,
       CASE 
           WHEN gr.winning_team_id = $1 THEN 'WIN'
           WHEN gr.winning_team_id IS NULL THEN 'DRAW'
           ELSE 'LOSS'
       END as result
FROM game_results gr
INNER JOIN games g ON gr.game_id = g.id
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
WHERE g.home_team_id = $1 OR g.away_team_id = $1
ORDER BY g.game_time DESC
`

type ListTeamGameResultsRow struct {
	ID            int64            `json:"id"`
	GameID        int64            `json:"gameId"`
	HomeScore     int32            `json:"homeScore"`
	AwayScore     int32            `json:"awayScore"`
	WinningTeamID pgtype.Int8      `json:"winningTeamId"`
	RecordedAt    pgtype.Timestamp `json:"recordedAt"`
	GameTime      pgtype.Timestamp `json:"gameTime"`
	HomeTeamID    int64            `json:"homeTeamId"`
	AwayTeamID    int64            `json:"awayTeamId"`
	HomeTeamName  string           `json:"homeTeamName"`
	AwayTeamName  string           `json:"awayTeamName"`
	TeamScore     interface{}      `json:"teamScore"`
	OpponentScore interface{}      `json:"opponentScore"`
	Result        string           `json:"result"`
}

// ListTeamGameResults
//
//	SELECT gr.id, gr.game_id, gr.home_score, gr.away_score, gr.winning_team_id, gr.recorded_at, g.game_time, g.home_team_id, g.away_team_id,
//	       ht.name as home_team_name,
//	       at.name as away_team_name,
//	       CASE
//	           WHEN g.home_team_id = $1 THEN gr.home_score
//	           WHEN g.away_team_id = $1 THEN gr.away_score
//	       END as team_score,
//	       CASE
//	           WHEN g.home_team_id = $1 THEN gr.away_score
//	           WHEN g.away_team_id = $1 THEN gr.home_score
//	       END as opponent_score,
//	       CASE
//	           WHEN gr.winning_team_id = $1 THEN 'WIN'
//	           WHEN gr.winning_team_id IS NULL THEN 'DRAW'
//	           ELSE 'LOSS'
//	       END as result
//	FROM game_results gr
//	INNER JOIN games g ON gr.game_id = g.id
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	WHERE g.home_team_id = $1 OR g.away_team_id = $1
//	ORDER BY g.game_time DESC
func (q *Queries) ListTeamGameResults(ctx context.Context, homeTeamID int64) ([]ListTeamGameResultsRow, error) {
	rows, err := q.db.Query(ctx, listTeamGameResults, homeTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTeamGameResultsRow{}
	for rows.Next() {
		var i ListTeamGameResultsRow
		if err := rows.Scan(
			&i.ID,
			&i.GameID,
			&i.HomeScore,
			&i.AwayScore,
			&i.WinningTeamID,
			&i.RecordedAt,
			&i.GameTime,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeTeamName,
			&i.AwayTeamName,
			&i.TeamScore,
			&i.OpponentScore,
			&i.Result,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGameResult = `-- name: UpdateGameResult :exec
UPDATE game_results
SET home_score = $1, away_score = $2, winning_team_id = $3, recorded_at = NOW()
WHERE id = $4
`

type UpdateGameResultParams struct {
	HomeScore     int32       `json:"homeScore"`
	AwayScore     int32       `json:"awayScore"`
	WinningTeamID pgtype.Int8 `json:"winningTeamId"`
	ID            int64       `json:"id"`
}

// UpdateGameResult
//
//	UPDATE game_results
//	SET home_score = $1, away_score = $2, winning_team_id = $3, recorded_at = NOW()
//	WHERE id = $4
func (q *Queries) UpdateGameResult(ctx context.Context, arg UpdateGameResultParams) error {
	_, err := q.db.Exec(ctx, updateGameResult,
		arg.HomeScore,
		arg.AwayScore,
		arg.WinningTeamID,
		arg.ID,
	)
	return err
}
