// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: teams.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (name, wins, losses, draws, points_for, points_against, created_at, updated_at)
values ($1, $2, $3, $4, $5, $6, NOW(), NOW())
RETURNING id, name, wins, losses, draws, points_for, points_against, created_at, updated_at
`

type CreateTeamParams struct {
	Name          string `json:"name"`
	Wins          int32  `json:"wins"`
	Losses        int32  `json:"losses"`
	Draws         int32  `json:"draws"`
	PointsFor     int32  `json:"pointsFor"`
	PointsAgainst int32  `json:"pointsAgainst"`
}

// CreateTeam
//
//	INSERT INTO teams (name, wins, losses, draws, points_for, points_against, created_at, updated_at)
//	values ($1, $2, $3, $4, $5, $6, NOW(), NOW())
//	RETURNING id, name, wins, losses, draws, points_for, points_against, created_at, updated_at
func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) (Team, error) {
	row := q.db.QueryRow(ctx, createTeam,
		arg.Name,
		arg.Wins,
		arg.Losses,
		arg.Draws,
		arg.PointsFor,
		arg.PointsAgainst,
	)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Wins,
		&i.Losses,
		&i.Draws,
		&i.PointsFor,
		&i.PointsAgainst,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams
WHERE id = $1
`

// DeleteTeam
//
//	DELETE FROM teams
//	WHERE id = $1
func (q *Queries) DeleteTeam(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTeam, id)
	return err
}

const getTeamById = `-- name: GetTeamById :one
SELECT id, name, wins, losses, draws, points_for, points_against, created_at, updated_at FROM teams where id = $1
`

// GetTeamById
//
//	SELECT id, name, wins, losses, draws, points_for, points_against, created_at, updated_at FROM teams where id = $1
func (q *Queries) GetTeamById(ctx context.Context, id int64) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamById, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Wins,
		&i.Losses,
		&i.Draws,
		&i.PointsFor,
		&i.PointsAgainst,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamStandings = `-- name: GetTeamStandings :many
SELECT id, name, wins, losses, draws, points_for, points_against,
       (wins * 3 + draws) as points,
       (points_for - points_against) as point_differential
FROM teams
ORDER BY points DESC, point_differential DESC, name ASC
`

type GetTeamStandingsRow struct {
	ID                int64  `json:"id"`
	Name              string `json:"name"`
	Wins              int32  `json:"wins"`
	Losses            int32  `json:"losses"`
	Draws             int32  `json:"draws"`
	PointsFor         int32  `json:"pointsFor"`
	PointsAgainst     int32  `json:"pointsAgainst"`
	Points            int32  `json:"points"`
	PointDifferential int32  `json:"pointDifferential"`
}

// GetTeamStandings
//
//	SELECT id, name, wins, losses, draws, points_for, points_against,
//	       (wins * 3 + draws) as points,
//	       (points_for - points_against) as point_differential
//	FROM teams
//	ORDER BY points DESC, point_differential DESC, name ASC
func (q *Queries) GetTeamStandings(ctx context.Context) ([]GetTeamStandingsRow, error) {
	rows, err := q.db.Query(ctx, getTeamStandings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeamStandingsRow{}
	for rows.Next() {
		var i GetTeamStandingsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Wins,
			&i.Losses,
			&i.Draws,
			&i.PointsFor,
			&i.PointsAgainst,
			&i.Points,
			&i.PointDifferential,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamStats = `-- name: GetTeamStats :one
SELECT t.id, t.name, t.wins, t.losses, t.draws, t.points_for, t.points_against, t.created_at, t.updated_at, 
       COUNT(p.id) as player_count
FROM teams t
LEFT JOIN players p ON p.team_id = t.id AND p.is_active = true
WHERE t.id = $1
GROUP BY t.id
`

type GetTeamStatsRow struct {
	ID            int64            `json:"id"`
	Name          string           `json:"name"`
	Wins          int32            `json:"wins"`
	Losses        int32            `json:"losses"`
	Draws         int32            `json:"draws"`
	PointsFor     int32            `json:"pointsFor"`
	PointsAgainst int32            `json:"pointsAgainst"`
	CreatedAt     pgtype.Timestamp `json:"createdAt"`
	UpdatedAt     pgtype.Timestamp `json:"updatedAt"`
	PlayerCount   int64            `json:"playerCount"`
}

// GetTeamStats
//
//	SELECT t.id, t.name, t.wins, t.losses, t.draws, t.points_for, t.points_against, t.created_at, t.updated_at,
//	       COUNT(p.id) as player_count
//	FROM teams t
//	LEFT JOIN players p ON p.team_id = t.id AND p.is_active = true
//	WHERE t.id = $1
//	GROUP BY t.id
func (q *Queries) GetTeamStats(ctx context.Context, id int64) (GetTeamStatsRow, error) {
	row := q.db.QueryRow(ctx, getTeamStats, id)
	var i GetTeamStatsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Wins,
		&i.Losses,
		&i.Draws,
		&i.PointsFor,
		&i.PointsAgainst,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PlayerCount,
	)
	return i, err
}

const getTeamWithPlayers = `-- name: GetTeamWithPlayers :many
SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered, 
       p.is_active, p.jersey_number, p.created_at, p.updated_at
FROM players p
WHERE p.team_id = $1
ORDER BY p.id
`

// GetTeamWithPlayers
//
//	SELECT p.id, p.user_id, p.team_id, p.registration_fee_due, p.is_fully_registered,
//	       p.is_active, p.jersey_number, p.created_at, p.updated_at
//	FROM players p
//	WHERE p.team_id = $1
//	ORDER BY p.id
func (q *Queries) GetTeamWithPlayers(ctx context.Context, teamID pgtype.Int8) ([]Player, error) {
	rows, err := q.db.Query(ctx, getTeamWithPlayers, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Player{}
	for rows.Next() {
		var i Player
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.RegistrationFeeDue,
			&i.IsFullyRegistered,
			&i.IsActive,
			&i.JerseyNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT id, name, wins, losses, draws, points_for, points_against, created_at, updated_at FROM teams
ORDER BY name
`

// ListTeams
//
//	SELECT id, name, wins, losses, draws, points_for, points_against, created_at, updated_at FROM teams
//	ORDER BY name
func (q *Queries) ListTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.Query(ctx, listTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Wins,
			&i.Losses,
			&i.Draws,
			&i.PointsFor,
			&i.PointsAgainst,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTeam = `-- name: UpdateTeam :exec
UPDATE teams
SET name = $1, wins = $2, losses = $3, draws = $4, points_for = $5, points_against = $6, updated_at = NOW()
WHERE id = $7
`

type UpdateTeamParams struct {
	Name          string `json:"name"`
	Wins          int32  `json:"wins"`
	Losses        int32  `json:"losses"`
	Draws         int32  `json:"draws"`
	PointsFor     int32  `json:"pointsFor"`
	PointsAgainst int32  `json:"pointsAgainst"`
	ID            int64  `json:"id"`
}

// UpdateTeam
//
//	UPDATE teams
//	SET name = $1, wins = $2, losses = $3, draws = $4, points_for = $5, points_against = $6, updated_at = NOW()
//	WHERE id = $7
func (q *Queries) UpdateTeam(ctx context.Context, arg UpdateTeamParams) error {
	_, err := q.db.Exec(ctx, updateTeam,
		arg.Name,
		arg.Wins,
		arg.Losses,
		arg.Draws,
		arg.PointsFor,
		arg.PointsAgainst,
		arg.ID,
	)
	return err
}
