// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: teams.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTeam = `-- name: CreateTeam :one
INSERT INTO teams (name, created_at, updated_at)
values ($1, NOW(), NOW())
RETURNING id, name, created_at, updated_at
`

// CreateTeam
//
//	INSERT INTO teams (name, created_at, updated_at)
//	values ($1, NOW(), NOW())
//	RETURNING id, name, created_at, updated_at
func (q *Queries) CreateTeam(ctx context.Context, name string) (Team, error) {
	row := q.db.QueryRow(ctx, createTeam, name)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM teams
WHERE id = $1
`

// DeleteTeam
//
//	DELETE FROM teams
//	WHERE id = $1
func (q *Queries) DeleteTeam(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteTeam, id)
	return err
}

const getTeamById = `-- name: GetTeamById :one
SELECT id, name, created_at, updated_at FROM teams where id = $1
`

// GetTeamById
//
//	SELECT id, name, created_at, updated_at FROM teams where id = $1
func (q *Queries) GetTeamById(ctx context.Context, id int64) (Team, error) {
	row := q.db.QueryRow(ctx, getTeamById, id)
	var i Team
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamWithPlayers = `-- name: GetTeamWithPlayers :one
SELECT t.id, t.name, p.user_id, u.first_name, u.last_name, p.id as player_id, p.jersey_number
FROM players p
INNER JOIN teams t on p.team_id = t.id
INNER JOIN users u on u.id = p.user_id
WHERE p.team_id = $1
ORDER BY p.id
`

type GetTeamWithPlayersRow struct {
	ID           int64       `json:"id"`
	Name         string      `json:"name"`
	UserID       int64       `json:"userId"`
	FirstName    string      `json:"firstName"`
	LastName     string      `json:"lastName"`
	PlayerID     int64       `json:"playerId"`
	JerseyNumber pgtype.Int4 `json:"jerseyNumber"`
}

// GetTeamWithPlayers
//
//	SELECT t.id, t.name, p.user_id, u.first_name, u.last_name, p.id as player_id, p.jersey_number
//	FROM players p
//	INNER JOIN teams t on p.team_id = t.id
//	INNER JOIN users u on u.id = p.user_id
//	WHERE p.team_id = $1
//	ORDER BY p.id
func (q *Queries) GetTeamWithPlayers(ctx context.Context, teamID pgtype.Int8) (GetTeamWithPlayersRow, error) {
	row := q.db.QueryRow(ctx, getTeamWithPlayers, teamID)
	var i GetTeamWithPlayersRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.PlayerID,
		&i.JerseyNumber,
	)
	return i, err
}

const getTeamWithPlayersDetailed = `-- name: GetTeamWithPlayersDetailed :many
SELECT t.id, t.name, t.created_at, t.updated_at, p.user_id, u.first_name, u.last_name, u.email, u.phone_number, 
        p.id as player_id, p.fee_remainder, p.jersey_number
FROM players p
INNER JOIN teams t on p.team_id = t.id
INNER JOIN users u on u.id = p.user_id
WHERE p.team_id = $1
ORDER BY p.id
`

type GetTeamWithPlayersDetailedRow struct {
	ID           int64            `json:"id"`
	Name         string           `json:"name"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	UserID       int64            `json:"userId"`
	FirstName    string           `json:"firstName"`
	LastName     string           `json:"lastName"`
	Email        string           `json:"email"`
	PhoneNumber  string           `json:"phoneNumber"`
	PlayerID     int64            `json:"playerId"`
	FeeRemainder int32            `json:"feeRemainder"`
	JerseyNumber pgtype.Int4      `json:"jerseyNumber"`
}

// GetTeamWithPlayersDetailed
//
//	SELECT t.id, t.name, t.created_at, t.updated_at, p.user_id, u.first_name, u.last_name, u.email, u.phone_number,
//	        p.id as player_id, p.fee_remainder, p.jersey_number
//	FROM players p
//	INNER JOIN teams t on p.team_id = t.id
//	INNER JOIN users u on u.id = p.user_id
//	WHERE p.team_id = $1
//	ORDER BY p.id
func (q *Queries) GetTeamWithPlayersDetailed(ctx context.Context, teamID pgtype.Int8) ([]GetTeamWithPlayersDetailedRow, error) {
	rows, err := q.db.Query(ctx, getTeamWithPlayersDetailed, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTeamWithPlayersDetailedRow{}
	for rows.Next() {
		var i GetTeamWithPlayersDetailedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.PhoneNumber,
			&i.PlayerID,
			&i.FeeRemainder,
			&i.JerseyNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamSchedule = `-- name: ListTeamSchedule :many
SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score,
       g.game_time, g.created_at, g.updated_at, g.status,
       ht.name as home_team_name,
       at.name as away_team_name
FROM games g
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
WHERE g.home_team_id = $1 OR g.away_team_id = $1
ORDER BY g.game_time
`

type ListTeamScheduleRow struct {
	ID           int64            `json:"id"`
	HomeTeamID   int64            `json:"homeTeamId"`
	AwayTeamID   int64            `json:"awayTeamId"`
	HomeScore    int32            `json:"homeScore"`
	AwayScore    int32            `json:"awayScore"`
	GameTime     pgtype.Timestamp `json:"gameTime"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	Status       string           `json:"status"`
	HomeTeamName string           `json:"homeTeamName"`
	AwayTeamName string           `json:"awayTeamName"`
}

// ListTeamSchedule
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score,
//	       g.game_time, g.created_at, g.updated_at, g.status,
//	       ht.name as home_team_name,
//	       at.name as away_team_name
//	FROM games g
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	WHERE g.home_team_id = $1 OR g.away_team_id = $1
//	ORDER BY g.game_time
func (q *Queries) ListTeamSchedule(ctx context.Context, homeTeamID int64) ([]ListTeamScheduleRow, error) {
	rows, err := q.db.Query(ctx, listTeamSchedule, homeTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTeamScheduleRow{}
	for rows.Next() {
		var i ListTeamScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeScore,
			&i.AwayScore,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.HomeTeamName,
			&i.AwayTeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeams = `-- name: ListTeams :many
SELECT id, name, created_at, updated_at FROM teams
ORDER BY name
`

// ListTeams
//
//	SELECT id, name, created_at, updated_at FROM teams
//	ORDER BY name
func (q *Queries) ListTeams(ctx context.Context) ([]Team, error) {
	rows, err := q.db.Query(ctx, listTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Team{}
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamsWithPlayers = `-- name: ListTeamsWithPlayers :many
SELECT t.id, t.name, p.user_id, u.first_name, u.last_name, p.id as player_id, p.jersey_number
FROM teams t
LEFT JOIN players p on t.id = p.team_id
LEFT JOIN users u on u.id = p.user_id
ORDER BY t.id
`

type ListTeamsWithPlayersRow struct {
	ID           int64       `json:"id"`
	Name         string      `json:"name"`
	UserID       pgtype.Int8 `json:"userId"`
	FirstName    pgtype.Text `json:"firstName"`
	LastName     pgtype.Text `json:"lastName"`
	PlayerID     pgtype.Int8 `json:"playerId"`
	JerseyNumber pgtype.Int4 `json:"jerseyNumber"`
}

// ListTeamsWithPlayers
//
//	SELECT t.id, t.name, p.user_id, u.first_name, u.last_name, p.id as player_id, p.jersey_number
//	FROM teams t
//	LEFT JOIN players p on t.id = p.team_id
//	LEFT JOIN users u on u.id = p.user_id
//	ORDER BY t.id
func (q *Queries) ListTeamsWithPlayers(ctx context.Context) ([]ListTeamsWithPlayersRow, error) {
	rows, err := q.db.Query(ctx, listTeamsWithPlayers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTeamsWithPlayersRow{}
	for rows.Next() {
		var i ListTeamsWithPlayersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.PlayerID,
			&i.JerseyNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamsWithPlayersDetailed = `-- name: ListTeamsWithPlayersDetailed :many
SELECT t.id, t.name, t.created_at, t.updated_at, p.user_id, u.first_name, u.last_name, u.email, u.phone_number, 
        p.id as player_id, p.fee_remainder, p.jersey_number
FROM teams t
LEFT JOIN players p on t.id = p.team_id
LEFT JOIN users u on u.id = p.user_id
ORDER BY t.id
`

type ListTeamsWithPlayersDetailedRow struct {
	ID           int64            `json:"id"`
	Name         string           `json:"name"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	UserID       pgtype.Int8      `json:"userId"`
	FirstName    pgtype.Text      `json:"firstName"`
	LastName     pgtype.Text      `json:"lastName"`
	Email        pgtype.Text      `json:"email"`
	PhoneNumber  pgtype.Text      `json:"phoneNumber"`
	PlayerID     pgtype.Int8      `json:"playerId"`
	FeeRemainder pgtype.Int4      `json:"feeRemainder"`
	JerseyNumber pgtype.Int4      `json:"jerseyNumber"`
}

// ListTeamsWithPlayersDetailed
//
//	SELECT t.id, t.name, t.created_at, t.updated_at, p.user_id, u.first_name, u.last_name, u.email, u.phone_number,
//	        p.id as player_id, p.fee_remainder, p.jersey_number
//	FROM teams t
//	LEFT JOIN players p on t.id = p.team_id
//	LEFT JOIN users u on u.id = p.user_id
//	ORDER BY t.id
func (q *Queries) ListTeamsWithPlayersDetailed(ctx context.Context) ([]ListTeamsWithPlayersDetailedRow, error) {
	rows, err := q.db.Query(ctx, listTeamsWithPlayersDetailed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTeamsWithPlayersDetailedRow{}
	for rows.Next() {
		var i ListTeamsWithPlayersDetailedRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.PhoneNumber,
			&i.PlayerID,
			&i.FeeRemainder,
			&i.JerseyNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTeamName = `-- name: UpdateTeamName :exec
UPDATE teams
SET name = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateTeamNameParams struct {
	Name string `json:"name"`
	ID   int64  `json:"id"`
}

// UpdateTeamName
//
//	UPDATE teams
//	SET name = $1, updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateTeamName(ctx context.Context, arg UpdateTeamNameParams) error {
	_, err := q.db.Exec(ctx, updateTeamName, arg.Name, arg.ID)
	return err
}
