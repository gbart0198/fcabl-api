// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: games.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGame = `-- name: CreateGame :one
INSERT INTO games (home_team_id, away_team_id, game_time, created_at, updated_at)
VALUES ($1, $2, $3, NOW(), NOW())
RETURNING id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status
`

type CreateGameParams struct {
	HomeTeamID int64            `json:"homeTeamId"`
	AwayTeamID int64            `json:"awayTeamId"`
	GameTime   pgtype.Timestamp `json:"gameTime"`
}

// CreateGame
//
//	INSERT INTO games (home_team_id, away_team_id, game_time, created_at, updated_at)
//	VALUES ($1, $2, $3, NOW(), NOW())
//	RETURNING id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRow(ctx, createGame, arg.HomeTeamID, arg.AwayTeamID, arg.GameTime)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.HomeScore,
		&i.AwayScore,
		&i.GameTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const deleteGame = `-- name: DeleteGame :exec
DELETE FROM games
WHERE id = $1
`

// DeleteGame
//
//	DELETE FROM games
//	WHERE id = $1
func (q *Queries) DeleteGame(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteGame, id)
	return err
}

const getGameById = `-- name: GetGameById :one
SELECT id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status FROM games WHERE id = $1
`

// GetGameById
//
//	SELECT id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status FROM games WHERE id = $1
func (q *Queries) GetGameById(ctx context.Context, id int64) (Game, error) {
	row := q.db.QueryRow(ctx, getGameById, id)
	var i Game
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.HomeScore,
		&i.AwayScore,
		&i.GameTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getGameWithTeams = `-- name: GetGameWithTeams :one
SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score, g.game_time, g.created_at, g.updated_at, g.status,
       ht.name as home_team_name, ht.wins as home_team_wins, ht.losses as home_team_losses,
       at.name as away_team_name, at.wins as away_team_wins, at.losses as away_team_losses
FROM games g
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
WHERE g.id = $1
`

type GetGameWithTeamsRow struct {
	ID             int64            `json:"id"`
	HomeTeamID     int64            `json:"homeTeamId"`
	AwayTeamID     int64            `json:"awayTeamId"`
	HomeScore      int32            `json:"homeScore"`
	AwayScore      int32            `json:"awayScore"`
	GameTime       pgtype.Timestamp `json:"gameTime"`
	CreatedAt      pgtype.Timestamp `json:"createdAt"`
	UpdatedAt      pgtype.Timestamp `json:"updatedAt"`
	Status         string           `json:"status"`
	HomeTeamName   string           `json:"homeTeamName"`
	HomeTeamWins   int32            `json:"homeTeamWins"`
	HomeTeamLosses int32            `json:"homeTeamLosses"`
	AwayTeamName   string           `json:"awayTeamName"`
	AwayTeamWins   int32            `json:"awayTeamWins"`
	AwayTeamLosses int32            `json:"awayTeamLosses"`
}

// GetGameWithTeams
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score, g.game_time, g.created_at, g.updated_at, g.status,
//	       ht.name as home_team_name, ht.wins as home_team_wins, ht.losses as home_team_losses,
//	       at.name as away_team_name, at.wins as away_team_wins, at.losses as away_team_losses
//	FROM games g
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	WHERE g.id = $1
func (q *Queries) GetGameWithTeams(ctx context.Context, id int64) (GetGameWithTeamsRow, error) {
	row := q.db.QueryRow(ctx, getGameWithTeams, id)
	var i GetGameWithTeamsRow
	err := row.Scan(
		&i.ID,
		&i.HomeTeamID,
		&i.AwayTeamID,
		&i.HomeScore,
		&i.AwayScore,
		&i.GameTime,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
		&i.HomeTeamName,
		&i.HomeTeamWins,
		&i.HomeTeamLosses,
		&i.AwayTeamName,
		&i.AwayTeamWins,
		&i.AwayTeamLosses,
	)
	return i, err
}

const listGames = `-- name: ListGames :many
SELECT id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status FROM games
ORDER BY game_time
`

// ListGames
//
//	SELECT id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status FROM games
//	ORDER BY game_time
func (q *Queries) ListGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, listGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeScore,
			&i.AwayScore,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGamesByTeam = `-- name: ListGamesByTeam :many
SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score, g.game_time, g.created_at, g.updated_at, g.status, 
t_home.name home_name, t_away.name away_name
FROM games g
INNER JOIN teams t_home on t_home.id = g.home_team_id
INNER JOIN teams t_away on t_away.id = g.away_team_id
WHERE home_team_id = $1 OR away_team_id = $1
ORDER BY game_time
`

type ListGamesByTeamRow struct {
	ID         int64            `json:"id"`
	HomeTeamID int64            `json:"homeTeamId"`
	AwayTeamID int64            `json:"awayTeamId"`
	HomeScore  int32            `json:"homeScore"`
	AwayScore  int32            `json:"awayScore"`
	GameTime   pgtype.Timestamp `json:"gameTime"`
	CreatedAt  pgtype.Timestamp `json:"createdAt"`
	UpdatedAt  pgtype.Timestamp `json:"updatedAt"`
	Status     string           `json:"status"`
	HomeName   string           `json:"homeName"`
	AwayName   string           `json:"awayName"`
}

// ListGamesByTeam
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score, g.game_time, g.created_at, g.updated_at, g.status,
//	t_home.name home_name, t_away.name away_name
//	FROM games g
//	INNER JOIN teams t_home on t_home.id = g.home_team_id
//	INNER JOIN teams t_away on t_away.id = g.away_team_id
//	WHERE home_team_id = $1 OR away_team_id = $1
//	ORDER BY game_time
func (q *Queries) ListGamesByTeam(ctx context.Context, homeTeamID int64) ([]ListGamesByTeamRow, error) {
	rows, err := q.db.Query(ctx, listGamesByTeam, homeTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGamesByTeamRow{}
	for rows.Next() {
		var i ListGamesByTeamRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeScore,
			&i.AwayScore,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.HomeName,
			&i.AwayName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGamesWithTeams = `-- name: ListGamesWithTeams :many
SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score, 
       g.game_time, g.created_at, g.updated_at, g.status,
       ht.name as home_team_name,
       at.name as away_team_name
FROM games g
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
ORDER BY g.game_time
`

type ListGamesWithTeamsRow struct {
	ID           int64            `json:"id"`
	HomeTeamID   int64            `json:"homeTeamId"`
	AwayTeamID   int64            `json:"awayTeamId"`
	HomeScore    int32            `json:"homeScore"`
	AwayScore    int32            `json:"awayScore"`
	GameTime     pgtype.Timestamp `json:"gameTime"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	Status       string           `json:"status"`
	HomeTeamName string           `json:"homeTeamName"`
	AwayTeamName string           `json:"awayTeamName"`
}

// ListGamesWithTeams
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score,
//	       g.game_time, g.created_at, g.updated_at, g.status,
//	       ht.name as home_team_name,
//	       at.name as away_team_name
//	FROM games g
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	ORDER BY g.game_time
func (q *Queries) ListGamesWithTeams(ctx context.Context) ([]ListGamesWithTeamsRow, error) {
	rows, err := q.db.Query(ctx, listGamesWithTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGamesWithTeamsRow{}
	for rows.Next() {
		var i ListGamesWithTeamsRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeScore,
			&i.AwayScore,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.HomeTeamName,
			&i.AwayTeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPastGames = `-- name: ListPastGames :many
SELECT id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status FROM games
WHERE game_time <= NOW()
ORDER BY game_time DESC
`

// ListPastGames
//
//	SELECT id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status FROM games
//	WHERE game_time <= NOW()
//	ORDER BY game_time DESC
func (q *Queries) ListPastGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, listPastGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeScore,
			&i.AwayScore,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTeamSchedule = `-- name: ListTeamSchedule :many
SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score,
       g.game_time, g.created_at, g.updated_at, g.status,
       ht.name as home_team_name,
       at.name as away_team_name
FROM games g
INNER JOIN teams ht ON g.home_team_id = ht.id
INNER JOIN teams at ON g.away_team_id = at.id
WHERE g.home_team_id = $1 OR g.away_team_id = $1
ORDER BY g.game_time
`

type ListTeamScheduleRow struct {
	ID           int64            `json:"id"`
	HomeTeamID   int64            `json:"homeTeamId"`
	AwayTeamID   int64            `json:"awayTeamId"`
	HomeScore    int32            `json:"homeScore"`
	AwayScore    int32            `json:"awayScore"`
	GameTime     pgtype.Timestamp `json:"gameTime"`
	CreatedAt    pgtype.Timestamp `json:"createdAt"`
	UpdatedAt    pgtype.Timestamp `json:"updatedAt"`
	Status       string           `json:"status"`
	HomeTeamName string           `json:"homeTeamName"`
	AwayTeamName string           `json:"awayTeamName"`
}

// ListTeamSchedule
//
//	SELECT g.id, g.home_team_id, g.away_team_id, g.home_score, g.away_score,
//	       g.game_time, g.created_at, g.updated_at, g.status,
//	       ht.name as home_team_name,
//	       at.name as away_team_name
//	FROM games g
//	INNER JOIN teams ht ON g.home_team_id = ht.id
//	INNER JOIN teams at ON g.away_team_id = at.id
//	WHERE g.home_team_id = $1 OR g.away_team_id = $1
//	ORDER BY g.game_time
func (q *Queries) ListTeamSchedule(ctx context.Context, homeTeamID int64) ([]ListTeamScheduleRow, error) {
	rows, err := q.db.Query(ctx, listTeamSchedule, homeTeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTeamScheduleRow{}
	for rows.Next() {
		var i ListTeamScheduleRow
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeScore,
			&i.AwayScore,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
			&i.HomeTeamName,
			&i.AwayTeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingGames = `-- name: ListUpcomingGames :many
SELECT id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status FROM games
WHERE game_time > NOW()
ORDER BY game_time
`

// ListUpcomingGames
//
//	SELECT id, home_team_id, away_team_id, home_score, away_score, game_time, created_at, updated_at, status FROM games
//	WHERE game_time > NOW()
//	ORDER BY game_time
func (q *Queries) ListUpcomingGames(ctx context.Context) ([]Game, error) {
	rows, err := q.db.Query(ctx, listUpcomingGames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Game{}
	for rows.Next() {
		var i Game
		if err := rows.Scan(
			&i.ID,
			&i.HomeTeamID,
			&i.AwayTeamID,
			&i.HomeScore,
			&i.AwayScore,
			&i.GameTime,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGame = `-- name: UpdateGame :exec
UPDATE games
SET home_team_id = $1, away_team_id = $2, game_time = $3, home_score = $4, away_score = $5, status = $6, updated_at = NOW()
WHERE id = $7
`

type UpdateGameParams struct {
	HomeTeamID int64            `json:"homeTeamId"`
	AwayTeamID int64            `json:"awayTeamId"`
	GameTime   pgtype.Timestamp `json:"gameTime"`
	HomeScore  int32            `json:"homeScore"`
	AwayScore  int32            `json:"awayScore"`
	Status     string           `json:"status"`
	ID         int64            `json:"id"`
}

// UpdateGame
//
//	UPDATE games
//	SET home_team_id = $1, away_team_id = $2, game_time = $3, home_score = $4, away_score = $5, status = $6, updated_at = NOW()
//	WHERE id = $7
func (q *Queries) UpdateGame(ctx context.Context, arg UpdateGameParams) error {
	_, err := q.db.Exec(ctx, updateGame,
		arg.HomeTeamID,
		arg.AwayTeamID,
		arg.GameTime,
		arg.HomeScore,
		arg.AwayScore,
		arg.Status,
		arg.ID,
	)
	return err
}

const updateGameScoreAndStatus = `-- name: UpdateGameScoreAndStatus :exec
UPDATE games
SET home_score = $1, away_score = $2, status = $3, updated_at = NOW()
WHERE id = $4
`

type UpdateGameScoreAndStatusParams struct {
	HomeScore int32  `json:"homeScore"`
	AwayScore int32  `json:"awayScore"`
	Status    string `json:"status"`
	ID        int64  `json:"id"`
}

// UpdateGameScoreAndStatus
//
//	UPDATE games
//	SET home_score = $1, away_score = $2, status = $3, updated_at = NOW()
//	WHERE id = $4
func (q *Queries) UpdateGameScoreAndStatus(ctx context.Context, arg UpdateGameScoreAndStatusParams) error {
	_, err := q.db.Exec(ctx, updateGameScoreAndStatus,
		arg.HomeScore,
		arg.AwayScore,
		arg.Status,
		arg.ID,
	)
	return err
}

const updateGameTime = `-- name: UpdateGameTime :exec
UPDATE games
SET game_time = $1, updated_at = NOW()
WHERE id = $2
`

type UpdateGameTimeParams struct {
	GameTime pgtype.Timestamp `json:"gameTime"`
	ID       int64            `json:"id"`
}

// UpdateGameTime
//
//	UPDATE games
//	SET game_time = $1, updated_at = NOW()
//	WHERE id = $2
func (q *Queries) UpdateGameTime(ctx context.Context, arg UpdateGameTimeParams) error {
	_, err := q.db.Exec(ctx, updateGameTime, arg.GameTime, arg.ID)
	return err
}
